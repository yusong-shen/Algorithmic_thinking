"""
Application 1

Citation graphs

Our task for this application is to analyze the structure of graphs
generated by citation patterns from scientific papers. 
Each scientific paper cites many other papers, say 20-40, and 
sometimes (e.g., review papers) hundreds of other papers. But, 
let's face it: It is often the case that the authors of a paper
are superficially familiar with some (many?) of the papers they 
cite. So, the question is: Are the cited papers chosen randomly 
(from within the domain of the paper) or is there some "hidden 
pattern"?

Algorithmic thinking
"""
from math import *
from project1 import make_complete_graph, compute_in_degrees, in_degree_distribution
import time
import matplotlib.pyplot as plt
import random
from alg_dpa_trial import DPATrial

start = time.clock()
# import alg_load_graph as lg
# citation_graph = lg.citation_graph

# for debugging
GRAPH5 = {0: set([1]),
          1: set([2]),
          2: set([3]),
          3: set([0])}

# Question 1
#------------
# Your task for this question is to compute the in-degree distribution
# for this citation graph. Once you have computed this distribution, 
# you should normalize the distribution
# (make the values in the dictionary sum to one) 
# and then compute a log/log plot of the points in this normalized 
# distribution. 


# # use small graph to dubug
# num_nodes = float(len(GRAPH5))
# print num_nodes
# distribution = in_degree_distribution(GRAPH5)

# # the large citation graph
# num_nodes = float(len(citation_graph))
# print "num_nodes:",num_nodes
# distribution = in_degree_distribution(citation_graph)

# # normalize the distribution
# for entry in distribution:
# 	distribution[entry] /= num_nodes
# print "finish normalize ..."
# elapsed = (time.clock() - start)
# print "Time used:", elapsed

# # print the normalized distribution
# keys = list(distribution.keys())
# items = []
# for key in distribution:
# 	items.append(distribution[key])
# # print "keys",keys
# # print "items",items
# plt.figure(1)
# plt.loglog(keys, items, 'ro')
# plt.xlabel('the log in-degree of node')
# plt.ylabel('the log number of nodes in particular in-degree')
# plt.grid(True)
# plt.title("the loglog in_degree_distribution for citation graph ")
# plt.show()

# print "Question 1 done"

# Question 2
#-----------------------------------------
# Algorithm 1:ER
# generating random undirected graphs
# def ER(num_nodes, probability):
# 	"""
# 	the ER function generating  a random undirected graph
# 	"""
# 	digraph = {}
# 	for node in range(num_nodes):
# 		neighbours = []
# 		for neighbour in range(num_nodes):
# 			a = random.uniform(0,1)
# 			if neighbour != node and a<probability:
# 				neighbours.append(neighbour)
# 		digraph[node]=set(neighbours)
# 	return digraph

# start = time.clock()
# probability = 0.1
# random_graph = ER(100, probability)

# # the random graph generated by ER function
# num_nodes2 = float(len(random_graph))
# print "num_nodes:",num_nodes2,"probability:",probability
# distribution2 = in_degree_distribution(random_graph)

# # normalize the distribution
# for entry in distribution2:
# 	distribution2[entry] /= num_nodes2
# print "finish normalize ..."
# elapsed = (time.clock() - start)
# print "Time used:", elapsed

# # print the normalized distribution
# keys = list(distribution2.keys())
# items = []
# for key in distribution2:
# 	items.append(distribution2[key])
# # print "keys",keys
# # print "items",items
# plt.figure(2)
# plt.loglog(keys, items, 'ro')
# plt.xlabel('the log in-degree of node')
# plt.ylabel('the log number of nodes in particular in-degree')
# plt.grid(True)
# plt.title("the loglog in_degree_distribution for random graph(p=%1.2f)"%(probability))
# # plt.show()

# plt.figure(3)
# plt.plot(keys, items, 'ro')
# plt.xlabel('the in-degree of node')
# plt.ylabel('the number of nodes in particular in-degree')
# plt.grid(True)
# plt.title("the in_degree_distribution for random graph(p=%1.2f)"%(probability))
# plt.show()
# print "Question 2 done"



# Question 3 
#------------------------------------
# a different process for generating syntheitc directed graph
# DPA
#  In this process, a random directed graph is generated iteratively, 
# where in each iteration a new node is created, added to the graph, 
# and connected to a subset of the existing nodes. 
# n :  the final number of nodes
# m :  the number of existing nodes to which a new node is connected
#	   during each iteration
# more specifically
# choose n equals to the number of nodes as the citation graph: n = 27700
# choose m equals to the average out-degree of the physics citation graph: m = ? 


def compute_out_degrees(digraph):
	"""
	take a directed graph represented as a dictionary and 
	compute the out-degrees for the nodes in the graph,
	return a dictionary like {a:2,b:2,c:2}
	"""
	out_degrees = {}
	for node in digraph:
		out_degree = len(digraph[node])
		out_degrees[node] = out_degree

	return out_degrees	

def out_degree_distribution(digraph):
	"""
	return a dictionary whose keys corresponding to out-degrees 
	of nodes in the graph, and the value associate with each 
	particular node is the the number of nodes with that out-degrees,
	like {2:3}
	"""
	distribution = {}
	out_degrees = compute_out_degrees(digraph)
	for node in out_degrees:
		out_degree = out_degrees[node]
		if out_degree not in distribution:
			distribution[out_degree] = 1
		else:
			distribution[out_degree] += 1

	return distribution

def average_out_degrees(digraph):
	"""
	compute the average out-degrees
	"""
	out_degrees = compute_out_degrees(digraph)
	sum = 0.0
	for key in out_degrees:
		sum += out_degrees[key]
	return sum/len(digraph)


# print GRAPH5
# print compute_out_degrees(GRAPH5)
# print average_out_degrees(GRAPH5)
# print "average_out_degrees(citation_graph):",average_out_degrees(citation_graph)


# Question 4
#------------------------------------
# your task for this question is to implement the DPA Algorithm
# compute a DPA graph using the values from question 3 .and then
# plot the in-degree distribution for this DPA graph


def DPA(num_nodes, m):
	"""
	DPA function return a DPA graph with num_nodes
	given num_nodes, and m : the number of existing nodes to which 
	a new node is connected in each iteration
	"""
	# make a m nodes completed graph
	m_node_comp_graph = make_complete_graph(m)
	current_graph = m_node_comp_graph
	dpatrial = DPATrial(m)
	for node in range(m, num_nodes):
		# sum of the in-degrees of existing nodes
		# choose randomly m nodes from V-current graph and
		# add them to V', where the probability of choosing node j
		# is (indeg(j)+1)/(totindeg+|V|)
		# totindeg = 0.0
		# in_degrees = compute_in_degrees(current_graph)
		# for node in in_degrees:
		# 	totindeg += in_degrees[node]
		# probability = (in_degrees[idx]+1.0)/(totindeg+len(current_graph))

		# using DPATrial class to encapsulate
		# optimized trials for DPA algorithm
		new_neighbours = dpatrial.run_trial(m)

		# new node i is added to set V
		# connect the new node to the randomly nodes
		current_graph.update({node:new_neighbours})
	return current_graph

# num_nodes = 27770
# m = 13

num_nodes = 27770
m = 13

# dpa = DPATrial(2)
# print dpa._node_numbers
# print dpa.run_trial(2)
# print dpa._node_numbers
# print dpa.run_trial(2)
# print dpa._node_numbers
# print dpa.run_trial(2)
# print dpa._node_numbers

# simulate the dpa digraph with 
# n,m obtained by Question 3
dpa_digraph = DPA(num_nodes, m)
# print dpa_digraph
# print average_out_degrees(dpa_digraph)

# the random graph generated by DPA function
num_nodes3 = float(len(dpa_digraph))
print "num_nodes:",num_nodes3
distribution3 = in_degree_distribution(dpa_digraph)

# print the normalized distribution
keys = list(distribution3.keys())
items = []
for key in distribution3:
	items.append(distribution3[key])
# print "keys",keys
# print "items",items
plt.figure(4)
plt.loglog(keys, items, 'ro')
plt.xlabel('the log in-degree of node')
plt.ylabel('the log number of nodes in particular in-degree')
plt.grid(True)
plt.title("the loglog in_degree_distribution for DPA random graph")
# plt.show()

plt.figure(5)
plt.plot(keys, items, 'ro')
plt.xlabel('the in-degree of node')
plt.ylabel('the number of nodes in particular in-degree')
plt.grid(True)
plt.title("the in_degree_distribution for DPA random graph")
plt.show()
print "Question 4 done"
